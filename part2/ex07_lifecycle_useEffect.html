<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- 


        ✅ 컴포넌트의 LifeCycle
        - 컴포넌트도 태어나고 언젠가 사라지는 라이프사이클이 있다~
        - 태어남 => 페이지에 장착된다 (mount)
        - 업데이트 => 재렌더링과 같은의미(update)
        - 제거된다 => (unmount)
        - 왜 배우냐면!!
            => 라이프사이클을 알고 있따면 중간중간 간섭을 할 수 있다
                => 중간중간 특정 코드를 넣는 등의 행동을 할 수 있다!!
                => 각각의 과정에 훅(hook)을 걸어둬서
                   특정 시기에 특정 코드를 실행시켜준다
        

                   
        ✅ 과거 class 문법
            class Detail02 extends React.Component {
                componentDidMount(){
                    // 컴포넌트 mount시 여기 코드가 실행됨
                }
                componentDidUpdate(){
                    // 컴포넌트 update시 여기 코드가 실행됨
                }
                componentWillUnmount(){
                    // 컴포넌트 unmount되려하면 여기 코드가 실행됨

                }
            }



        ✅ 최근 함수 컴포넌트 내 useEffect 문법
            function Detail(){
                useEffect(()=>{
                    // mount, update시 여기 코드가 실행
                }) 
            }



        ✅ 언제 쓸까??
            - 그냥 컴포넌트 안 아무곳에나 써놔도 재렌더링되면 실행되는거 아님?
            - 맞긴한데,
            - useEffect 내부 함수는 모든 html이 렌더링 된 후에 동작!!
            - 시간이 오래걸리는 작업이 위에 있으면 렌더링이 지연될 수 있는데,
            - 그게 useEffect 안에 있으면 다른 렌더링 작업을 먼저 해줌
            - 그래서 useEffect 안에 적는 코드들은
                => 어려운 연산
                => 서버에서 데이터 가져오는 작업 
                => 타이머 장착하는 거
                    🔸 JavaSript에서 타이머
                    - setTimeout(()=> {실행할 코드}, 지연시간(밀리초))



        ✅ useEffect의 실행조건(dependency)
        - 사실 useEffect는 파라미터로 콜백함수 외 배열 하나를 더 가지고 있음
            useEffect(()=>{
                setTimeout(()=>{
                    실행코드
                }, 2000)
            }, [🔸 여기 🔸])
        - 내부에 state나 변수를 넣을 수 있음
        - 배열 자체를 입력하지 않으면? => mount, update 될 때마다 재실행
        - 빈 배열을 넣으면? => mount에만 실행됨
        - 해당 배열에 state나 변수가 있으면?
            => 배열 요소의 값이 변경될 때만 재렌더링
        


        ✅ useEffect의 return문
        - useEffect 콜백함수 내부에 return문을 넣을 수 있음
            useEffect(()=>{
                setTimeout(()=>{
                    실행코드
                    return ()=>{
                        🔸 여기 🔸
                    }
                }, 2000)
            }, [])
        - 리턴문 안 코드(함수)는 useEffect 동작 전에 실행됨
        - 순서 정리 => 조건에 따라 useEffect가 실행될 재렌더링이 일어나면
            => html 요소들 렌더링 => useEffect 콜백함수 return문 실행
            => useEffect 콜백함수 내부 코드 실행

        - 리턴문 내의 함수는 clean up function이라고도 하는데
        - 재렌더링이 잦은 react 특성상, 타이머 등을 설정하면 
          의도치않게 중복적으로 막 생겨날 수 있음.
            => 실행하기 전에 기존 타이머를 제거하는 코드 있으면 편리
            => 이렇게 기존 코드 깨끗이 치우는 역할로 많이 사용

        - useEffect에서 서버로 데이터 요청하는 경우가 있음
          그 때 요청이 마무리되기 전에 계속 재렌더링이 일어나면 코드가 쌓여서 버그의 원인이됨
            => 이럴 때도 기존 데이터요청을 제거하는 clean up 코드 있으면 좋음
        
        - 실행코드 없이 리턴문만 쓰면 unmount시에만 실행
        - clean up function은 mount시에는 실행안됨
          but unmount시에는 실행됨




        ** 참고사항
            - 리액트 하다가 콘솔에 찍어보면 꼭 2번씩 찍히는 경우가 있는데
            - 이건 개발 과정에서 디버깅 절차 때문
            - 없애려면 index.jsx의 StrictMode 제거

            - 왜 effect인가?
                => 함수의 핵심기능과 상관없는 부가기능이 side effect
                => 여기서 따옴!!












     -->
</body>
</html>